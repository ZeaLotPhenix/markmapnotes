# 多线程/并发编程

## 相关面试题

### 面试题顺序

- 81 269 450 谈谈你对 AQS 的理解

- 82 270 fail-safe 机制与 fail-fast 机制分别有什么作用

- 100 221 288 829 lock 和 synchronized 区别

- 102 290 线程池如何知道一个线程的任务已经执行完成
555 线程池的线程回收
580 线程池是如何实现线程复用的
583 任务数超过线程池核心线程数时,怎样让不进入队列而是启用最大线程数

- 119 307 CAS机制

- 134 死锁的发生原因和避免

- 203 为什么阿里不推荐使用Java自带的线程池

- 231 356 wait和notify为什么要在synchorized代码块中?
- 图解java多线程设计模式中是介绍了哪几种wait和notify的使用方法?
- 252 守护线程及其特点

- 253 522 AbstractQueuedSynchorized为什么采用双向链表

- 339 volatile关键字的作用及原理

- 358 ThreadLocal及其实现原理
621 794 ThreadLocal会出现内存泄漏吗

- 366 935 怎么理解线程安全

- 368 @Contented注解了解过吗?讲一下伪共享的概念以及如何避免

- 391 941 ReentranLock的实现原理
461ReentranLock如何实现公平锁与非公平锁

- 399 简述一下你对线程池的理解

- 409 911 如何安全中断一个正在运行的线程

- 423 偏向锁 轻量级锁 及锁的升级流程

- 466 722 CompleteFuture的理解

- 473 线程状态BLOCKED和WAITING的区别

- 487 Thread和Runable的区别
569 同一个线程两次调用start会有什么问题

- 572 HappensBefore的理解

- 这个跟虚拟机的指令重排相关
https://blog.csdn.net/Fly_as_tadpole/article/details/86238651

- 586 SimpleDateFormat是线程安全的吗?

- 携程里面关于时间的处理类有哪些?避免了哪些坑?

- 594 并行和并发有什么区别

- 925 可重入锁及应用

### 面试侧重点

- 线程/进程的基本概念

- 134 死锁的发生原因和避免

- 252 守护线程及其特点

- 366 935 怎么理解线程安全

- 473 线程状态BLOCKED和WAITING的区别

- 487 Thread和Runable的区别
569 同一个线程两次调用start会有什么问题

- 409 911 如何安全中断一个正在运行的线程

- 594 并行和并发有什么区别

- 锁/共享/内存可见性

- 100 221 288 829 lock 和 synchronized 区别

- 134 死锁的发生原因和避免

- 119 307 CAS机制

- 339 volatile关键字的作用及原理

- 423 偏向锁 轻量级锁 及锁的升级流程

- 391 941 ReentranLock的实现原理
461ReentranLock如何实现公平锁与非公平锁

- 925 可重入锁及应用

- 并发集合/并发工具类

- 81 269 450 谈谈你对 AQS 的理解

- 119 307 CAS机制

- 线程池

- 102 290 线程池如何知道一个线程的任务已经执行完成
555 线程池的线程回收
580 线程池是如何实现线程复用的
583 任务数超过线程池核心线程数时,怎样让不进入队列而是启用最大线程数

- 203 为什么阿里不推荐使用Java自带的线程池

- 携程的有哪些线程池

- AutoCompose中的线程池是怎样的

- 399 简述一下你对线程池的理解

- ThreadLocal

- 358 ThreadLocal及其实现原理
621 794 ThreadLocal会出现内存泄漏吗

- 466 722 CompleteFuture的理解

- 586 SimpleDateFormat是线程安全的吗?

- 携程里面关于时间的处理类有哪些?避免了哪些坑?

- 111 299 ConcurrentHashMap 底层具体实现知道吗？实现原理是什么?
618 788 为什么ConcurrentHashMap的key,value不允许为null
783 ConcurrentHashMap是如何保证线程安全的

## AQS
AbstractQueuedSynchronizer

### 排它锁
存在多线程竞争同一共享资源时，同一时刻只允许一个线程访问该共享资源，也就是多个线程中只能有一个线程获得锁资源

- Lock

- ReentrantLock重

### 共享锁
也称为读锁，就是在同一时刻允许多个线程同时获得锁资源，

- CountDownLatch

- Semaphore

### 为什么使用双向链表

- 双向遍历

- 判断前驱节点的sign状态
自旋竞争时判断前驱节点是否是头节点

## 并发集合

### 失败处理机制

- fail-safe
是采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容

- java.util.concurrent 包下的容器都是fail-safe的

- ConcerrentHashMap

- CopyOnWriteArrayList

- fail-fast
集合遍历过程中，一旦发现容器中的数据被修改了，会立刻抛出 ConcurrentModificationException 异常，从而导致遍历失败

- java.util 包下的集合类都是fail-fast机制

- HashMap

- ArrayList

### 阻塞队列
在生产者消费者模型的场景中使用

- 有界队列

- ArrayBlockingList

- 无界队列

- LinkedBlockingQueue

- Zookeeper

## 线程安全

### synchronized
Synchronized 只提供了一种非公平锁的实现。
偏向锁、轻量级锁、重量级锁以及锁升级

- wait()

- notify()

### J.U.C.Lock
自旋锁的方式来实现性能优化

- 公平锁
指线程竞争锁资源时，如果已经有其他线程正在排队等待锁释放，那么当前竞争锁资源的线程无法插队

- 非公平锁
不管是否有线程在排队等待锁，它都会尝试去竞争一次锁。

### 守护线程DaemonThread

- setDeamon(true)

- The Java Virtual Machine exits when the only threads running are all daemon threads.

## 线程池

### 执行完成

## ThreadLocal
多线程下对共享变量访问的安全性

## CAS(CompareAndSwap)
保证在多线程环境下，对于共享变量的修改的原子性

### Java Native方法

### jdk.internal.misc包

### J.U.C 里面 Atomic 的原子实现，比如 AtomicInteger，AtomicLong

### 是实现多线程对共享资源竞争的互斥性质，比如在AQS、ConcurrentHashMap、ConcurrentLinkedQueue 等都有用到