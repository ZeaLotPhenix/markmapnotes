# 多线程/并发编程

## 相关面试题
- 面试题顺序 <!-- markmap: foldAll-->
    - 81 269 450 谈谈你对 AQS 的理解
    - 82 270 fail-safe 机制与 fail-fast 机制分别有什么作用
    - 100 221 288 829 lock 和 synchronized 区别
    - 102 290 线程池如何知道一个线程的任务已经执行完成
    555 线程池的线程回收
    580 线程池是如何实现线程复用的
    583 任务数超过线程池核心线程数时,怎样让不进入队列而是启用最大线程数
    - 119 307 CAS机制
    - 134 死锁的发生原因和避免
    - 203 为什么阿里不推荐使用Java自带的线程池
    - 231 356 wait和notify为什么要在synchorized代码块中?
    - 图解java多线程设计模式中是介绍了哪几种wait和notify的使用方法?
    - 252 守护线程及其特点
    - 253 522 AbstractQueuedSynchorized为什么采用双向链表
    - 339 volatile关键字的作用及原理
    - 358 ThreadLocal及其实现原理
    621 794 ThreadLocal会出现内存泄漏吗
    - 366 935 怎么理解线程安全
    - 368 @Contented注解了解过吗?讲一下伪共享的概念以及如何避免
    - 391 941 ReentranLock的实现原理
    461ReentranLock如何实现公平锁与非公平锁
    - 399 简述一下你对线程池的理解
    - 409 911 如何安全中断一个正在运行的线程
    - 423 偏向锁 轻量级锁 及锁的升级流程
    - 466 722 CompleteFuture的理解
    - 473 线程状态BLOCKED和WAITING的区别
    - 487 Thread和Runable的区别
    569 同一个线程两次调用start会有什么问题
    - 572 HappensBefore的理解
    - 这个跟虚拟机的指令重排相关
    https://blog.csdn.net/Fly_as_tadpole/article/details/86238651
    - 586 SimpleDateFormat是线程安全的吗?
    - 携程里面关于时间的处理类有哪些?避免了哪些坑?
    - 594 并行和并发有什么区别
    - 925 可重入锁及应用
- 面试侧重点 <!-- markmap: foldAll -->
    - 线程/进程的基本概念
        - 134 死锁的发生原因和避免
        - 252 守护线程及其特点
        - 366 935 怎么理解线程安全
        - 473 线程状态BLOCKED和WAITING的区别
        - 487 Thread和Runable的区别
        569 同一个线程两次调用start会有什么问题
        - 409 911 如何安全中断一个正在运行的线程
        - 594 并行和并发有什么区别
        - 锁/共享/内存可见性
        - 100 221 288 829 lock 和 synchronized 区别
        - 134 死锁的发生原因和避免
        - 119 307 CAS机制
        - 339 volatile关键字的作用及原理
        - 423 偏向锁 轻量级锁 及锁的升级流程
        - 391 941 ReentranLock的实现原理
        461ReentranLock如何实现公平锁与非公平锁
        - 925 可重入锁及应用
    - 并发集合/并发工具类
        - 81 269 450 谈谈你对 AQS 的理解
        - 119 307 CAS机制
    - 线程池
        - 102 290 线程池如何知道一个线程的任务已经执行完成
        555 线程池的线程回收
        580 线程池是如何实现线程复用的
        583 任务数超过线程池核心线程数时,怎样让不进入队列而是启用最大线程数
        - 203 为什么阿里不推荐使用Java自带的线程池
        - 携程的有哪些线程池
        - AutoCompose中的线程池是怎样的
        - 399 简述一下你对线程池的理解
    - JUC集合包
        - ThreadLocal
        - 358 ThreadLocal及其实现原理
        621 794 ThreadLocal会出现内存泄漏吗
        - 466 722 CompleteFuture的理解
        - 586 SimpleDateFormat是线程安全的吗?
        - 携程里面关于时间的处理类有哪些?避免了哪些坑?
        - 111 299 ConcurrentHashMap 底层具体实现知道吗？实现原理是什么?
        618 788 为什么ConcurrentHashMap的key,value不允许为null
        783 ConcurrentHashMap是如何保证线程安全的

## JUC并发包
AbstractQueuedSynchronizer
### 排它锁
存在多线程竞争同一共享资源时，同一时刻只允许一个线程访问该共享资源，也就是多个线程中只能有一个线程获得锁资源
- Lock
- ReentrantLock重
### 共享锁
也称为读锁，就是在同一时刻允许多个线程同时获得锁资源，
- CountDownLatch
- Semaphore
### 为什么使用双向链表
- 双向遍历
- 判断前驱节点的sign状态
自旋竞争时判断前驱节点是否是头节点
## 并发集合
### 阻塞队列
在生产者消费者模型的场景中使用
- 有界队列
- ArrayBlockingList
- 无界队列
- LinkedBlockingQueue
- Zookeeper
## 线程安全
### synchronized
Synchronized 只提供了一种非公平锁的实现。
偏向锁、轻量级锁、重量级锁以及锁升级
- wait()
- notify()
### J.U.C.Lock
自旋锁的方式来实现性能优化
- 公平锁
指线程竞争锁资源时，如果已经有其他线程正在排队等待锁释放，那么当前竞争锁资源的线程无法插队
- 非公平锁
不管是否有线程在排队等待锁，它都会尝试去竞争一次锁。
### 守护线程DaemonThread
- setDeamon(true)
- The Java Virtual Machine exits when the only threads running are all daemon threads.
## 线程池
### 执行完成
## ThreadLocal
多线程下对共享变量访问的安全性
## CAS(CompareAndSwap)
保证在多线程环境下，对于共享变量的修改的原子性
### Java Native方法
### jdk.internal.misc包
### J.U.C 里面 Atomic 的原子实现，比如 AtomicInteger，AtomicLong
### 是实现多线程对共享资源竞争的互斥性质，比如在AQS、ConcurrentHashMap、ConcurrentLinkedQueue 等都有用到

## 基本概念
### 线程管理
- 线程的定义
现代操作系统调度的最小单元是线程，也叫轻量级进程，在一个进程里可以创建多个线程
    - 私有属性
        - 计数器
        - 堆栈
        - 局部变量
    - 同一个进程的线程们可访问共享的内存变量
- 线程的声明周期
    - 线程状态变迁示例图 <!-- markmap: foldAll -->
        - ![<<Java并发编程艺术>> 图4-1](https://mmbiz.qpic.cn/mmbiz_png/EoJib2tNvVtdIAujm9mNP0iaPyAh3pibzbicat48F4A7u8HGcXL7HHAzhPEpQBmrQ0F0WN9zrdiaj28AhRsdeyrAcOA/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1)
    - 图解
        - New：新创建的线程，尚未执行；
        - Runnable：运行中的线程，正在执行run()方法的 Java 代码；
        - Blocked：运行中的线程，因为某些操作被阻塞而挂起；
        - Waiting：运行中的线程，因为某些操作在等待中；
        - Timed Waiting：运行中的线程，因为执行sleep()方法正在计时等待；
        - Terminated：线程已终止，因为run()方法执行完毕。
- 线程通信
    - 8种线程间通信方式
        - volatile
            - 定义
            当某个变量被 volatile 修饰并且发生改变时，volatile 变量底层会通过 lock 前缀的指令，将该变量写会主存，同时利用 缓存一致性协议，促使其他线程的本地变量的数据无效，从而再次直接从主存读取数据
        - synchronized
            - 定义
            synchronized 的实现原理是对一 个对象的监视器（ObjectMonitor）进行获取，而这个获取过程是排他的，也就是同一时刻只能有一个 线程获取到由 synchronized 所保护对象的监视器。
            监视器锁（Monitor 另一个名字叫管程）本质是依赖于底层的操作系统的 Mutex Lock（互斥锁）来实现的
        - Thread线程协作
            - interrupt()中断目标线程
            [api doc](https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#interrupt--)
            - join()等待目标线程执行完毕
            [api doc](https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#join--)
                - 重要特性
                    - 可中断性​​：join()方法会响应中断，抛出InterruptedException
                    - ​​happens-before关系​​：线程B的所有操作对线程A可见（线程A在join()返回后能看到线程B的所有修改）
                    - 重入性​​：一个线程可以多次join()另一个线程
                - 注意事项
                    - 不要在持有锁的情况下调用join()，可能导致死锁
                    - 正确处理InterruptedException
                    - 过度使用join()可能导致程序失去并发优势
                - 应用场景
                    - 等待后台任务完成后再继续主流程
                    - 确保某些初始化工作完成后再执行后续操作
                    - 实现线程间的顺序执行（虽然通常有更好的替代方案）
        - Object等待/通知机制
        [api doc](https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html)
            - wait()
            - notify()
            - notifyAll()
        - 管道输入/输出
- 线程同步机制
    - 锁（Lock）机制
        - 定位: 锁是​​多线程/分布式系统​​中最基础的同步工具，负责在并发访问共享资源（如内存、文件、数据库）时，​​划定临界区​​（Critical Section），确保同一时间只有一个执行流能进入
        - 核心思想: 互斥和临界区保护
            - 互斥: “​​同一时间只有一个线程能持有锁​​”，其他线程必须等待锁释放（阻塞或自旋）
            - 临界区保护: 被锁保护的代码块，内部操作需​​满足原子性、可见性、有序性
        - 锁的分类
            - 线程竞争策略: 是否假设并发冲突一定会发生​​，并提前预防冲突
                - 悲观锁Pessimistic Locking
                ​​假设​​：并发访问时一定会发生冲突，因此 ​​先加锁再操作
                - 乐观锁Optimistic Locking
                ​​假设​​：并发冲突概率低，因此 ​​先操作，冲突时再处理​​（如 CAS、版本号机制）
            - 可重入性: ​​同一个线程能否重复获取同一把锁
                - 可重入锁Reentrant Lock
                - 不可重入锁Non-Reentrant Lock
            - 线程获取锁的顺序: ​​是否按照线程请求锁的顺序分配锁
                - 公平锁Fair Lock
                - 非公平锁Non-Fair Lock
            - 锁的共享性: 锁是否允许多个线程同时访问资源​​
                - 共享锁Shared Lock 
                - 排他锁Exclusive Lock
    - 同步原语（Synchronization Primitives）机制
        - 定位​​：​​显式的线程协作工具​​，通过阻塞或唤醒线程实现同步
        - ​​核心思想​​：​​控制线程的执行顺序​​，确保共享资源的互斥访问或条件依赖的满足
        - 同步原语的分类
            - 互斥原语（Mutex）
            保证同一时间只有一个线程能访问共享资源（临界区）
                - synchronized关键字
                - ReentrantLock
            - 信号量原语（Semaphore）
            限制同时访问资源的线程数量（可允许多线程，但数量受限）
                - Semaphore
            - 条件变量原语（Condition）
            让线程在特定条件不满足时主动等待，条件满足时被唤醒（需配合锁使用）
                - Condition
            - 屏障原语（Barrier）
            让一组线程互相等待，直到所有线程到达某个同步点后才继续执行
                - CyclicBarrier
                - Phaser
    - ​原子性（Atomicity）机制​​
        - 定位​​：​​无锁（Lock-Free）的同步机制​​，通过硬件指令（如CAS）保证单操作的不可分割性。
        - ​核心思想​​：​​避免线程阻塞​​，通过原子操作直接修改共享数据，无需显式锁
        - 原子性的分类
            - CAS（Compare-And-Swap）
            - 原子变量（Atomic Variables）
### 资源限制
- 定义
指在进行并发编程时，程序的执行速度受限于计算机硬件资源或软件资源, 盲目增大并行线程数只会徒劳增加上下文切换和资源调度时间导致适得其反
    - 常见资源限制
        - 网络带宽
        - 硬盘读写速度
        - CPU处理速度哦
        - 数据库连接数
        - Socket连接数
### 锁
- Synchronized关键字实现的锁
通常使用synchronized关键字来给一段代码或一个方法上锁
    - 三种常见形式
        - 修饰普通函数，监视器锁（monitor）便是对象实例（this）
        - 修饰静态静态函数，视器锁（monitor）便是对象的Class实例（每个对象只有一个Class实例）
        - 修饰代码块，监视器锁（monitor）是指定对象实例
    - 底层实现原理
        - 通过monitorenter与monitorexit指令（获取锁、释放锁）
        - 任何对象都有一个监视器锁（monitor）关联，线程执行monitorenter指令时尝试获取monitor的所有权
        - 执行流程图 <!-- markmap: foldAll -->
            - ![监视器锁执行流程图](https://mmbiz.qpic.cn/mmbiz_png/EoJib2tNvVtdIAujm9mNP0iaPyAh3pibzbicUhROnKqZ2ibpsUC4BwBbsibmkibXOtVddDJlgK2iadTQibYwFZoJnKHuxLg/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1)
            -  [Synchronized 机制及锁膨胀流程](https://www.processon.com/view/62c005a10e3e746592070665)
    - 四种锁状态
        - 无锁状态
        - 偏向锁状态
        - 轻量级锁状态
        - 重量级锁状态
- Lock接口
- Condition接口
- 锁的分类
    - 排它锁
    存在多线程竞争同一共享资源时，同一时刻只允许一个线程访问该共享资源，也就是多个线程中只能有一个线程获得锁资源
    - 共享锁
    也称为读锁，就是在同一时刻允许多个线程同时获得锁资源
### 死锁
- 定义
两个或两个以上的线程持有不同系统资源的锁，线程彼此都等待获取对方的锁来完成自己的任务，但是没有让出自己持有的锁，线程就会无休止等待下去
    - 常见竞争资源
        - 锁
        - 网络连接
        - 通知事件
        - 磁盘
        - 带宽
- 检测手段
    - jstack检测目标JVM进程(JDK自带)
- 解决措施
    - 避免一个线程同时获取多个锁。
    - 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。
    - 尝试使用定时锁，使用 lock.tryLock（timeout）来替代使用内部锁机制。
    - 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况
### 并发集合
- 失败机制
    - fail-safe
    采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容
        - java.util.concurrent 包下的容器都是fail-safe的
            - ConcerrentHashMap
            - CopyOnWriteArrayList
    - fail-fast
    集合遍历过程中，一旦发现容器中的数据被修改了，会立刻抛出 ConcurrentModificationException 异常，从而导致遍历失败
        - java.util 包下的集合类都是fail-fast机制
            - HashMap
            - ArrayList
## 具体实现
- java.lang
    - [Thread](https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html)
    - [ThreadLocal](https://docs.oracle.com/javase/8/docs/api/java/lang/ThreadLocal.html)
- java.util.concurrent
    - interface接口
        - [BlockingQueue](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html)
    - class类
        - [ConcurrentHashMap]()
        - 七种阻塞队列
            - [ArrayBlockingQueue]()
            - [LinkedBlockingQueue]()
            - [PriorityBlockingQueue]()
            - [DelayQueue]()
            - [SynchronousQueue]()
            - [LinkedTransferQueue]()
            - [LinkedBlockingDeque]()
- java.util.concurrent.atomic
    - [AtomicInteger](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicInteger.html)
    - [AtomicReference](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicReference.html)
    - [AtomicReferenceArray](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicReferenceArray.html)
- java.util.concurrent.locks
    - [AbstractQueuedSynchronizer](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/AbstractQueuedSynchronizer.html)
    - [ReentrantLock](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReentrantLock.html)
    - [ReentrantReadWriteLock](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html)

